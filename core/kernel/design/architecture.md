# FynMesh Architecture

FynMesh is a large enterprise scale web application framework with Module Federation & Micro Frontends, enabling modular, scalable applications through independently deployable microfrontends (FynApps).

## Core Principles

- **Independent Development**: Teams develop and deploy FynApps autonomously
- **Shared Dependencies**: Efficient sharing of common libraries and utilities
- **Federation-First**: Built on proven Module Federation technology
- **ES Modules Only**: Modern module system for clean, standardized interfaces
- **Type Safety**: Full type safety and modern language features
- **Automatic Dependencies**: Build-time detection and runtime resolution

## System Components

### The Kernel

The kernel orchestrates the entire FynMesh ecosystem with unified APIs across browser and Node.js environments.

**Core Responsibilities:**
- **Lifecycle Management**: FynApp loading, initialization, and bootstrap coordination
- **Federation Integration**: Interface with Module Federation containers and shared scopes
- **Dependency Resolution**: Ensure proper load order based on FynApp dependencies
- **Platform Abstraction**: Unified API across environments
- **Runtime Coordination**: Manage shared services and inter-FynApp communication

**Platform Implementations:**
- **Browser Kernel**: DOM-based loading and client-side federation
- **Node Kernel**: Server-side rendering and federation support

### FynApp Structure

FynApps are self-contained microfrontends with clear boundaries and standardized interfaces.

**Development Structure:**
```
fynapp/
├── package.json          # NPM package with FynApp dependencies
├── rollup.config.ts      # Federation and build configuration
├── src/
│   ├── main.ts          # Entry point and bootstrap logic
│   ├── config.ts        # FynApp configuration
│   └── components/      # Application components
└── tsconfig.json        # TypeScript configuration
```

**Build Output:**
```
dist/
├── federation.json      # Federation metadata and dependencies
├── fynapp-entry.js     # FynMesh federation entry point
├── main.js             # Application bundle
└── assets/             # Static resources
```

**Configuration:**
- Module exposure and sharing through federation plugin
- Dependency declarations in package.json
- Build optimization and compilation
- Standardized entry points with main function and optional configuration

### Federation Integration

FynMesh leverages Module Federation through the `@fynmesh/federation-js` package.

**Key Components:**
- **Container**: Module Federation container interface
- **FederationEntry**: Typed interface for federation entry modules
- **Share Scope**: Shared dependency management
- **Dynamic Loading**: Runtime module resolution

**Capabilities:**
- Container setup and share scope integration
- Dynamic module loading and resolution
- Direct access to federation containers

### Dependency System

FynApps can depend on other FynApps through shared modules and exposed components, with automatic detection and resolution.

**Dependency Types:**
- **Shared Module Dependencies**: Consuming shared libraries from provider FynApps
- **Exposed Module Dependencies**: Dynamic imports of components from other FynApps

**Process:**
- **Build-Time**: Rollup plugin detects dependencies during build
- **Runtime**: Kernel resolves load order and validates dependencies
- **Storage**: Dependencies stored in federation.json for runtime use

*For detailed dependency detection, resolution algorithms, and implementation phases, see [fynapp-dependencies.md](./fynapp-dependencies.md)*

## Runtime Flow

**Kernel Initialization:**
Platform-specific kernel instantiation → Runtime data structure initialization → Share scope and federation setup → Ready for FynApp loading

**FynApp Loading:**
Load federation.json from FynApp URL → Parse dependency information → Resolve dependency load order → Load federation entry modules → Initialize federation containers

**FynApp Bootstrap:**
Validate all dependencies are loaded → Bootstrap FynApps in dependency order → Execute FynApp initialization logic → Register with kernel runtime

**Runtime Operation:**
Inter-FynApp communication through kernel → Shared dependency resolution → Dynamic module loading → Lifecycle management

## File Formats

### federation.json
Generated by the build process, contains federation metadata and dependencies:
```json
{
  "name": "my-fynapp",
  "version": "1.0.0",
  "dependencies": [
    {
      "fynapp": "provider-fynapp",
      "reason": "shared-module-consumption",
      "provides": ["react", "lodash"]
    }
  ],
  "exposes": {
    "./main": "./main.js"
  },
  "entry": "./fynapp-entry.js",
  "shared": {
    "react": { "singleton": true }
  }
}
```

### FynApp Entry Point
FynApps export standardized entry points with main function for initialization, optional configuration metadata, and full type safety.

## Development Workflow

**FynApp Development:**
Create FynApp using template → Configure federation and build settings → Develop components and logic → Declare dependencies in package.json → Build and test locally

**Dependency Management:**
Configure shared modules in federation settings → Declare FynApp dependencies in package.json → Automatic build-time detection via rollup plugin → Runtime resolution handled by kernel

**Deployment:**
Compile and generate federation bundles → Deploy build output to CDN/server → Configure FynApp URLs in host applications → Kernel manages loading and dependencies automatically

## Platform Support

**Browser Environment:**
DOM integration, client-side federation, asset management, development tools

**Node.js Environment:**
Server-side rendering, file system access, process integration, build tools

## Best Practices

**FynApp Design:**
- Keep FynApps focused and single-purpose
- Use clear, typed interfaces for exposed modules
- Implement proper error boundaries
- Follow consistent naming conventions

**Dependency Management:**
- Minimize cross-FynApp dependencies
- Use shared modules for common libraries
- Version dependencies appropriately
- Document public interfaces

**Performance:**
- Optimize bundle sizes and loading
- Use code splitting effectively
- Implement proper caching strategies
- Monitor federation overhead

**Development:**
- Use TypeScript for type safety
- Implement comprehensive testing
- Follow semantic versioning
- Maintain backward compatibility

## Future Considerations

- **Advanced Dependency Resolution**: Third-party provider scenarios and resolution modes
- **Performance Optimization**: Bundle concatenation and loading strategies
- **Development Tooling**: Enhanced debugging and development experience
- **Ecosystem Integration**: Framework-specific adapters and tooling
