globalThis.Federation._mfBind({n:"react-context",f:"react-context-vqKz4Z2O.js",c:"fynapp-react-middleware",s:"fynmesh",e:!1,v:"1.0.0"},["src/middleware"]).register(["esm-react"],function(e){"use strict";var t,o,n,r,s,a,i,c;return{setters:[function(e){t=e.default,o=e.createContext,n=e.useMemo,r=e.useContext,s=e.useState,a=e.useRef,i=e.useEffect,c=e.useCallback}],execute:function(){class d{constructor(){this.memoryStorage=new Map}getStorageKey(e,t){return t?`${e.key}-${t}`:e.key}getStorageType(e){return e.storage||e.type||"memory"}load(e,t,o){try{const n=this.getStorageKey(e,o),r=this.getStorageType(e);let s=null;switch(r){case"localStorage":"undefined"!=typeof window&&window.localStorage&&(s=localStorage.getItem(n));break;case"sessionStorage":"undefined"!=typeof window&&window.sessionStorage&&(s=sessionStorage.getItem(n));break;case"memory":s=this.memoryStorage.get(n)||null}if(s){const e="string"==typeof s?JSON.parse(s):s;return{...t,...e}}}catch(e){console.warn("Failed to load persisted state:",e)}return t}save(e,t,o){try{const n=this.getStorageKey(e,o),r=this.getStorageType(e),s=JSON.stringify(t);switch(r){case"localStorage":"undefined"!=typeof window&&window.localStorage&&localStorage.setItem(n,s);break;case"sessionStorage":"undefined"!=typeof window&&window.sessionStorage&&sessionStorage.setItem(n,s);break;case"memory":this.memoryStorage.set(n,s)}}catch(e){console.warn("Failed to persist state:",e)}}clear(e,t){try{const o=this.getStorageKey(e,t);switch(this.getStorageType(e)){case"localStorage":"undefined"!=typeof window&&window.localStorage&&localStorage.removeItem(o);break;case"sessionStorage":"undefined"!=typeof window&&window.sessionStorage&&sessionStorage.removeItem(o);break;case"memory":this.memoryStorage.delete(o)}}catch(e){console.warn("Failed to clear persisted state:",e)}}}function l(e,d){const l=o(void 0);function h(){const t=r(l);if(void 0===t)throw new Error(`useContext for ${e.contextName} must be used within its Provider`);return t}return{Provider:function({children:o,fynAppId:r,externalState:h}){const[f,m]=s(()=>h?h.getState():e.persistence?d.load(e.persistence,e.initialState,r):e.initialState),[g,u]=n(()=>h?[h.getState(),h.setState]:[f,m],[h,f]),y=a(g);i(()=>{if(h)return h.subscribe(()=>{const e=h.getState();m(e)})},[h]),i(()=>{!h&&e.persistence&&y.current!==g&&d.save(e.persistence,g,r),y.current=g},[g,r,h]);const x=n(()=>{if(!e.actions)return{};const t={};return Object.entries(e.actions).forEach(([o,n])=>{t[o]=(...t)=>{h&&"function"==typeof h[o]?h[o](...t):u(r=>{var s,a,i;try{let i,c;if("function"==typeof n)i=n;else{if(!n||"object"!=typeof n||!("reducer"in n))return console.warn(`Invalid action definition for ${o} in context ${e.contextName}`),r;i=n.reducer,c=n.validator}if(c&&!c(r,...t))return console.warn(`Validation failed for action ${o} in context ${e.contextName}`,t),r;if((null===(s=e.middleware)||void 0===s?void 0:s.validation)&&!e.middleware.validation(r,e.contextName))return console.warn(`State validation failed for context ${e.contextName}`),r;const d=i(r,...t),l="function"==typeof d?{...r,...d(r)}:{...r,...d};return(null===(a=e.middleware)||void 0===a?void 0:a.onStateChange)&&e.middleware.onStateChange(r,l,o,e.contextName),l}catch(t){return console.error(`Error in action ${o} for context ${e.contextName}:`,t),(null===(i=e.middleware)||void 0===i?void 0:i.onError)&&e.middleware.onError(t instanceof Error?t:new Error(String(t)),e.contextName),r}})}}),t},[h]),p=c(t=>{var o;if(h){const n=h.getState(),r="function"==typeof t?{...n,...t(n)}:{...n,...t};h.setState(r),(null===(o=e.middleware)||void 0===o?void 0:o.onStateChange)&&e.middleware.onStateChange(n,r,"setState",e.contextName)}else u(o=>{var n,r;try{const r="function"==typeof t?{...o,...t(o)}:{...o,...t};return(null===(n=e.middleware)||void 0===n?void 0:n.onStateChange)&&e.middleware.onStateChange(o,r,"setState",e.contextName),r}catch(t){return console.error(`Error in setState for context ${e.contextName}:`,t),(null===(r=e.middleware)||void 0===r?void 0:r.onError)&&e.middleware.onError(t instanceof Error?t:new Error(String(t)),e.contextName),o}})},[h]),S=n(()=>({state:g,actions:x,setState:p}),[g,x,p,h]);return t.createElement(l.Provider,{value:S},o)},useContext:h,useContextSelector:function(e){const{state:t}=h();return n(()=>e(t),[t,e])},Context:l}}e("ReactContextMiddleware",class{constructor(){this.name="react-context",this.storageManager=new d,this.contextFactories=new Map,this.contextInstances=new WeakMap,this.sharedContexts=new Map,this.sharedProviderInstances=new Map,this.sharedProviderSymbols=new Map,this.sharedStateStores=new Map,this.secondaryConsumers=new Set}async setup(e){console.log(`${this.name} middleware initialized`)}isReadyForUser(e){if(console.log(`ðŸ” ${this.name} checking readiness for user requirements:`,e),!e)return!0;if("consumer"===e.mode&&e.requiredContexts){for(const t of e.requiredContexts)if(!this.sharedContexts.has(t))return console.log(`âŒ Required shared context "${t}" not available yet`),!1;return console.log("âœ… All required shared contexts available"),!0}return"provider"===e.mode?(console.log("âœ… Provider mode - ready to create contexts"),!0):(console.log("âœ… Unknown mode - defaulting to ready"),!0)}async apply(e){try{return e.meta.requireReady&&!this.readyCallback&&(this.readyCallback=e.meta.requireReady),e.meta.config?"string"==typeof e.meta.config&&"consume-only"===e.meta.config?(console.log(`${this.name} middleware: ${e.fynApp.name} is a secondary consumer, exposing shared contexts only`),void await this.handleSecondaryConsumer(e)):"object"==typeof e.meta.config&&e.meta.config.contexts?void console.log(`${this.name} middleware: ${e.fynApp.name} is a primary provider, processing full configuration`):void console.log(`${this.name} middleware: Invalid configuration for ${e.fynApp.name}, skipping application`):void console.log(`${this.name} middleware: No configuration found for ${e.fynApp.name}, skipping application`)}catch(t){throw console.error(`Error applying ${this.name} middleware to ${e.fynApp.name}:`,t),t}}async handlePrimaryProvider(e){const t=this.validateConfig(e.meta.config),o=this.normalizeContextsConfig(t.contexts);console.log(`Processing ${o.length} contexts for primary provider ${e.fynApp.name}`),this.contextInstances.has(e.fynApp)||this.contextInstances.set(e.fynApp,new Map);const n=this.contextInstances.get(e.fynApp);for(const t of o)await this.createContext(e,t,n);this.exposeContextAPIs(e.fynApp,n)}async handleSecondaryConsumer(e){this.secondaryConsumers.add(e.fynApp),this.contextInstances.has(e.fynApp)||this.contextInstances.set(e.fynApp,new Map);const t=this.contextInstances.get(e.fynApp);for(const[o,n]of this.sharedContexts.entries()){const r=this.sharedProviderSymbols.get(o),s=this.sharedProviderInstances.get(o);if(r&&s){const r={contextName:o,initialState:{},shared:!0};t.set(o,{factory:n,config:r,shared:!0}),console.log(`Secondary consumer ${e.fynApp.name} can access shared context "${o}"`)}}this.exposeContextAPIs(e.fynApp,t),0===this.sharedContexts.size&&console.log(`Secondary consumer ${e.fynApp.name} loaded before primary provider - shared contexts will be available once primary loads`)}validateConfig(e){if(!e||"object"!=typeof e)throw new Error("Invalid configuration: config must be an object");if(!e.contexts)throw new Error("Invalid configuration: contexts property is required");return e}normalizeContextsConfig(e){if(Array.isArray(e))return e.map(e=>{if(!e.contextName)throw new Error("Context configuration missing contextName");return e});if("object"==typeof e)return Object.entries(e).map(([e,t])=>({...t,contextName:e}));throw new Error("Invalid contexts configuration: must be array or object")}async createContext(e,o,n){const r=o.shared?o.contextName:`${e.fynApp.name}-${o.contextName}`;let s;if(o.shared)if(this.sharedContexts.has(o.contextName))console.log(`Reusing existing shared context factory for "${o.contextName}"`),s=this.sharedContexts.get(o.contextName);else{console.log(`Creating shared context factory for "${o.contextName}"`),s=l(o,this.storageManager),this.sharedContexts.set(o.contextName,s);const e=Symbol(`shared-provider-${o.contextName}`);this.sharedProviderSymbols.set(o.contextName,e);const n=this.createSharedStateStore(o);this.sharedStateStores.set(o.contextName,n);const r=({children:e})=>t.createElement(s.Provider,{children:e,externalState:n});this.sharedProviderInstances.set(o.contextName,r),console.log(`Created shared Provider instance with shared store for "${o.contextName}"`),this.readyCallback&&1===this.sharedContexts.size&&(console.log(`ðŸ”” ${this.name} middleware signaling ready - first shared context created`),this.readyCallback()),this.updateSecondaryConsumers(o.contextName,s)}else this.contextFactories.has(r)?s=this.contextFactories.get(r):(console.log(`Creating FynApp-specific context factory for "${r}"`),s=l(o,this.storageManager),this.contextFactories.set(r,s));n.set(o.contextName,{factory:s,config:o,shared:o.shared||!1}),console.log(`Configured context "${o.contextName}" for ${e.fynApp.name} (shared: ${o.shared||!1})`)}updateSecondaryConsumers(e,t){for(const o of this.secondaryConsumers){const n=this.contextInstances.get(o);if(n){const r=this.sharedProviderSymbols.get(e),s=this.sharedProviderInstances.get(e);if(r&&s){const r={contextName:e,initialState:{},shared:!0};n.set(e,{factory:t,config:r,shared:!0}),this.exposeContextAPIs(o,n),console.log(`Updated secondary consumer ${o.name} with new shared context "${e}"`)}}}}createSharedStateStore(e){if("counter"===e.contextName){const e=new Set;let t={count:0};const o={getState:()=>t,setState:o=>{t={...t,...o},e.forEach(e=>e())},subscribe:t=>(e.add(t),()=>e.delete(t)),increment:()=>{t={...t,count:t.count+1},e.forEach(e=>e())},decrement:()=>{t={...t,count:t.count-1},e.forEach(e=>e())},reset:()=>{t={...t,count:0},e.forEach(e=>e())}};return console.log("Created shared state store for counter context"),o}return{getState:()=>({}),setState:()=>{},subscribe:()=>()=>{}}}exposeContextAPIs(e,t){const o={},n={};for(const[r,s]of t.entries()){const{factory:t,config:a}=s;if(a.shared){const s=this.sharedProviderInstances.get(r),a=this.sharedProviderSymbols.get(r);o[r]={useContext:t.useContext,useContextSelector:t.useContextSelector,Context:t.Context,Provider:t.Provider,SharedProvider:s},a&&(n[r]=a),console.log(`Exposed shared Provider for context "${r}" to ${e.name}`)}else o[r]={useContext:t.useContext,useContextSelector:t.useContextSelector,Context:t.Context,Provider:t.Provider}}const r=()=>{const e={};for(const[t,o]of this.sharedProviderSymbols.entries())e[t]=o;return e};e.middlewareContext.set(this.name,{...o,getSharedProvider:e=>{for(const[t,o]of this.sharedProviderSymbols.entries())if(o===e)return this.sharedProviderInstances.get(t)},getLazySharedSymbols:r}),e.middlewareContext.set(`${this.name}:shared-symbols`,r()),Object.keys(n).length>0&&console.log(`Stored shared provider symbols for ${Object.keys(n).join(", ")} in ${e.name}`),console.log(`Exposed ${Object.keys(o).join(", ")} context APIs to ${e.name} via middlewareContext`)}cleanup(e){const t=this.contextInstances.get(e);if(t){for(const[o,n]of t.entries())n.config.persistence&&this.storageManager.clear(n.config.persistence,n.shared?void 0:e.name);this.contextInstances.delete(e)}this.secondaryConsumers.delete(e)}listContexts(e){if(e){const t=this.contextInstances.get(e);return t?Array.from(t.keys()):[]}return Array.from(this.contextFactories.keys())}})}}});
//# sourceMappingURL=react-context-vqKz4Z2O.js.map
