{"version":3,"file":"react-context-vqKz4Z2O.js","sources":["../src/middleware/react-context.tsx"],"sourcesContent":["// @ts-ignore\nimport React, { \n  createContext, \n  useContext, \n  useState, \n  useCallback, \n  useRef, \n  useEffect, \n  useMemo,\n  ReactNode,\n} from \"react\";\n\nimport type { FynApp, FynAppMiddleware, FynAppMiddlewareCallContext } from \"@fynmesh/kernel\";\n\n// =============================================================================\n// Type Definitions\n// =============================================================================\n\n/**\n * Action definition with optional validation\n */\nexport interface ActionDefinition<T = any> {\n  reducer: (state: T, ...args: any[]) => Partial<T> | ((prevState: T) => Partial<T>);\n  validator?: (state: T, ...args: any[]) => boolean;\n}\n\n/**\n * Storage configuration for context persistence\n */\nexport interface PersistenceConfig {\n  key: string;\n  storage: 'localStorage' | 'sessionStorage' | 'memory';\n  /** @deprecated Use storage instead */\n  type?: 'localStorage' | 'sessionStorage' | 'memory';\n}\n\n/**\n * Middleware hooks for context state changes\n */\nexport interface ContextMiddlewareHooks<T = any> {\n  onStateChange?: (oldState: T, newState: T, action: string, contextName: string) => void;\n  validation?: (state: T, contextName: string) => boolean;\n  onError?: (error: Error, contextName: string) => void;\n}\n\n/**\n * Configuration for a single context\n */\nexport interface ContextConfig<T = any> {\n  contextName: string;\n  initialState: T;\n  actions?: Record<string, ActionDefinition<T> | ((state: T, ...args: any[]) => Partial<T>)>;\n  persistence?: PersistenceConfig;\n  shared?: boolean;\n  middleware?: ContextMiddlewareHooks<T>;\n}\n\n/**\n * Context value provided to React components\n */\nexport interface ContextValue<T = any> {\n  state: T;\n  actions: Record<string, (...args: any[]) => void>;\n  setState: (updater: Partial<T> | ((prevState: T) => Partial<T>)) => void;\n}\n\n/**\n * Configuration for the React Context middleware\n */\nexport interface ReactContextMiddlewareConfig {\n  contexts: ContextConfig[] | Record<string, Omit<ContextConfig, 'contextName'>>;\n}\n\n/**\n * Context factory interface\n */\ninterface ContextFactory<T = any> {\n  Provider: React.ComponentType<{ children: ReactNode; fynAppId?: string; externalState?: any }>;\n  useContext: () => ContextValue<T>;\n  useContextSelector: <K>(selector: (state: T) => K) => K;\n  Context: React.Context<ContextValue<T> | undefined>;\n}\n\n/**\n * Context instance data\n */\ninterface ContextInstanceData {\n  factory: ContextFactory;\n  config: ContextConfig;\n  shared: boolean;\n}\n\n// =============================================================================\n// Error Boundary Component\n// =============================================================================\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  contextName: string;\n  onError?: (error: Error, contextName: string) => void;\n}\n\nfunction ContextErrorBoundary({ children, contextName, onError }: ErrorBoundaryProps) {\n  // Simple error boundary wrapper\n  // For production, consider using react-error-boundary library\n  try {\n    return React.createElement(React.Fragment, null, children);\n  } catch (error) {\n    console.error(`Error in context ${contextName}:`, error);\n    onError?.(error instanceof Error ? error : new Error(String(error)), contextName);\n    \n    return React.createElement('div', {\n      style: { padding: '20px', border: '1px solid red', backgroundColor: '#fee' }\n    }, [\n      React.createElement('h3', { key: 'title' }, `Context Error: ${contextName}`),\n      React.createElement('p', { key: 'message' }, 'An error occurred in this context. Check console for details.'),\n    ]);\n  }\n}\n\n// =============================================================================\n// Storage Manager\n// =============================================================================\n\nclass StorageManager {\n  private memoryStorage = new Map<string, any>();\n\n  private getStorageKey(config: PersistenceConfig, fynAppId?: string): string {\n    return fynAppId ? `${config.key}-${fynAppId}` : config.key;\n  }\n\n  private getStorageType(config: PersistenceConfig): 'localStorage' | 'sessionStorage' | 'memory' {\n    // Handle legacy 'type' property\n    return config.storage || config.type || 'memory';\n  }\n\n  load<T>(config: PersistenceConfig, initialState: T, fynAppId?: string): T {\n    try {\n      const key = this.getStorageKey(config, fynAppId);\n      const storageType = this.getStorageType(config);\n      \n      let stored: string | null = null;\n      \n      switch (storageType) {\n        case 'localStorage':\n          if (typeof window !== 'undefined' && window.localStorage) {\n            stored = localStorage.getItem(key);\n          }\n          break;\n        case 'sessionStorage':\n          if (typeof window !== 'undefined' && window.sessionStorage) {\n            stored = sessionStorage.getItem(key);\n          }\n          break;\n        case 'memory':\n          stored = this.memoryStorage.get(key) || null;\n          break;\n      }\n      \n      if (stored) {\n        const parsedState = typeof stored === 'string' ? JSON.parse(stored) : stored;\n        return { ...initialState, ...parsedState };\n      }\n    } catch (error) {\n      console.warn(`Failed to load persisted state:`, error);\n    }\n    \n    return initialState;\n  }\n\n  save<T>(config: PersistenceConfig, state: T, fynAppId?: string): void {\n    try {\n      const key = this.getStorageKey(config, fynAppId);\n      const storageType = this.getStorageType(config);\n      const serialized = JSON.stringify(state);\n      \n      switch (storageType) {\n        case 'localStorage':\n          if (typeof window !== 'undefined' && window.localStorage) {\n            localStorage.setItem(key, serialized);\n          }\n          break;\n        case 'sessionStorage':\n          if (typeof window !== 'undefined' && window.sessionStorage) {\n            sessionStorage.setItem(key, serialized);\n          }\n          break;\n        case 'memory':\n          this.memoryStorage.set(key, serialized);\n          break;\n      }\n    } catch (error) {\n      console.warn(`Failed to persist state:`, error);\n    }\n  }\n\n  clear(config: PersistenceConfig, fynAppId?: string): void {\n    try {\n      const key = this.getStorageKey(config, fynAppId);\n      const storageType = this.getStorageType(config);\n      \n      switch (storageType) {\n        case 'localStorage':\n          if (typeof window !== 'undefined' && window.localStorage) {\n            localStorage.removeItem(key);\n          }\n          break;\n        case 'sessionStorage':\n          if (typeof window !== 'undefined' && window.sessionStorage) {\n            sessionStorage.removeItem(key);\n          }\n          break;\n        case 'memory':\n          this.memoryStorage.delete(key);\n          break;\n      }\n    } catch (error) {\n      console.warn(`Failed to clear persisted state:`, error);\n    }\n  }\n}\n\n// =============================================================================\n// Context Provider Factory\n// =============================================================================\n\nfunction createContextProvider<T>(config: ContextConfig<T>, storageManager: StorageManager): ContextFactory<T> {\n  const Context = createContext<ContextValue<T> | undefined>(undefined);\n\n  function Provider({ children, fynAppId, externalState }: { children: ReactNode; fynAppId?: string; externalState?: any }) {\n    // Use external state store if provided, otherwise use internal React state\n    const [internalState, setInternalState] = useState<T>(() => {\n      if (externalState) {\n        // If using external state, get initial state from it\n        return externalState.getState();\n      }\n      // Load initial state from persistence for internal state\n      if (config.persistence) {\n        return storageManager.load(config.persistence, config.initialState, fynAppId);\n      }\n      return config.initialState;\n    });\n\n    const [state, setState] = useMemo(() => {\n      if (externalState) {\n        // Use external state store\n        return [externalState.getState(), externalState.setState];\n      }\n      // Use internal React state\n      return [internalState, setInternalState];\n    }, [externalState, internalState]);\n\n    const prevStateRef = useRef<T>(state);\n\n    // Subscribe to external state changes\n    useEffect(() => {\n      if (externalState) {\n        const unsubscribe = externalState.subscribe(() => {\n          const newState = externalState.getState();\n          setInternalState(newState);\n        });\n        return unsubscribe;\n      }\n    }, [externalState]);\n\n    // Persist state changes (only for internal state, external state handles its own persistence)\n    useEffect(() => {\n      if (!externalState && config.persistence && prevStateRef.current !== state) {\n        storageManager.save(config.persistence, state, fynAppId);\n      }\n      prevStateRef.current = state;\n    }, [state, fynAppId, externalState]);\n\n    // Create memoized actions\n    const actions = useMemo(() => {\n      if (!config.actions) return {};\n\n      const actionMap: Record<string, (...args: any[]) => void> = {};\n\n      Object.entries(config.actions).forEach(([actionName, actionDef]) => {\n        actionMap[actionName] = (...args: any[]) => {\n          // Use external state methods if available and action name matches\n          if (externalState && typeof externalState[actionName] === 'function') {\n            externalState[actionName](...args);\n            return;\n          }\n          \n          // Otherwise use regular setState logic\n          setState((prevState: T) => {\n            try {\n              // Handle both old and new action formats\n              let actionFn: (state: T, ...args: any[]) => Partial<T> | ((prevState: T) => Partial<T>);\n              let validator: ((state: T, ...args: any[]) => boolean) | undefined;\n              \n              if (typeof actionDef === 'function') {\n                // Legacy format: direct function\n                actionFn = actionDef;\n              } else if (actionDef && typeof actionDef === 'object' && 'reducer' in actionDef) {\n                // New format: { validator, reducer }\n                actionFn = actionDef.reducer;\n                validator = actionDef.validator;\n              } else {\n                console.warn(`Invalid action definition for ${actionName} in context ${config.contextName}`);\n                return prevState;\n              }\n              \n              // Validate action arguments if validator exists\n              if (validator && !validator(prevState, ...args)) {\n                console.warn(`Validation failed for action ${actionName} in context ${config.contextName}`, args);\n                return prevState;\n              }\n\n              // Validate current state if global validator provided\n              if (config.middleware?.validation && !config.middleware.validation(prevState, config.contextName)) {\n                console.warn(`State validation failed for context ${config.contextName}`);\n                return prevState;\n              }\n\n              const result = actionFn(prevState, ...args);\n              const newState = typeof result === 'function' \n                ? { ...prevState, ...result(prevState) }\n                : { ...prevState, ...result };\n\n              // Call middleware hook\n              if (config.middleware?.onStateChange) {\n                config.middleware.onStateChange(prevState, newState, actionName, config.contextName);\n              }\n\n              return newState;\n            } catch (error) {\n              console.error(`Error in action ${actionName} for context ${config.contextName}:`, error);\n              if (config.middleware?.onError) {\n                config.middleware.onError(error instanceof Error ? error : new Error(String(error)), config.contextName);\n              }\n              return prevState;\n            }\n          });\n        };\n      });\n\n      return actionMap;\n    }, [externalState]);\n\n    // Generic setState function\n    const setStateGeneric = useCallback((updater: Partial<T> | ((prevState: T) => Partial<T>)) => {\n      if (externalState) {\n        // Use external state's setState method\n        const currentState = externalState.getState();\n        const newState = typeof updater === 'function' \n          ? { ...currentState, ...updater(currentState) }\n          : { ...currentState, ...updater };\n        \n        externalState.setState(newState);\n        \n        if (config.middleware?.onStateChange) {\n          config.middleware.onStateChange(currentState, newState, 'setState', config.contextName);\n        }\n      } else {\n        // Use internal React state\n        setState((prevState: T) => {\n          try {\n            const newState = typeof updater === 'function' \n              ? { ...prevState, ...updater(prevState) }\n              : { ...prevState, ...updater };\n\n            if (config.middleware?.onStateChange) {\n              config.middleware.onStateChange(prevState, newState, 'setState', config.contextName);\n            }\n\n            return newState;\n          } catch (error) {\n            console.error(`Error in setState for context ${config.contextName}:`, error);\n            if (config.middleware?.onError) {\n              config.middleware.onError(error instanceof Error ? error : new Error(String(error)), config.contextName);\n            }\n            return prevState;\n          }\n        });\n      }\n    }, [externalState]);\n\n    const value: ContextValue<T> = useMemo(() => ({\n      state,\n      actions,\n      setState: setStateGeneric,\n    }), [state, actions, setStateGeneric, externalState]);\n\n    return React.createElement(Context.Provider, { value }, children);\n  }\n\n  // Custom hook for consuming the context\n  function useContextHook(): ContextValue<T> {\n    const context = useContext(Context);\n    if (context === undefined) {\n      throw new Error(`useContext for ${config.contextName} must be used within its Provider`);\n    }\n    return context;\n  }\n\n  // Selector hook for performance optimization\n  function useContextSelector<K>(selector: (state: T) => K): K {\n    const { state } = useContextHook();\n    return useMemo(() => selector(state), [state, selector]);\n  }\n\n  return {\n    Provider,\n    useContext: useContextHook,\n    useContextSelector,\n    Context,\n  };\n}\n\n// =============================================================================\n// Middleware Implementation\n// =============================================================================\n\nexport class ReactContextMiddleware implements FynAppMiddleware {\n  public readonly name = \"react-context\";\n\n  private storageManager = new StorageManager();\n  private contextFactories = new Map<string, ContextFactory>();\n  private contextInstances = new WeakMap<FynApp, Map<string, ContextInstanceData>>();\n  private sharedContexts = new Map<string, ContextFactory>();\n  private sharedProviderInstances = new Map<string, React.ComponentType<{ children: ReactNode }>>();\n  private sharedProviderSymbols = new Map<string, symbol>();\n  private sharedStateStores = new Map<string, any>(); // NEW: Shared state stores outside React\n  private secondaryConsumers = new Set<FynApp>(); // Track secondary consumers for updates\n  private readyCallback?: () => void; // 🆕 Callback to signal readiness\n\n  async setup(_context: FynAppMiddlewareCallContext): Promise<void> {\n    console.log(`${this.name} middleware initialized`);\n  }\n\n  /**\n   * Check if middleware is ready for specific user requirements\n   * This is called after user.initialize() to determine if we can fulfill their needs\n   */\n  isReadyForUser(userRequirements: any): boolean {\n    console.log(`🔍 ${this.name} checking readiness for user requirements:`, userRequirements);\n    \n    // If no specific requirements, we're ready\n    if (!userRequirements) {\n      return true;\n    }\n    \n    // Handle consumer mode - check if required contexts exist\n    if (userRequirements.mode === \"consumer\" && userRequirements.requiredContexts) {\n      for (const contextName of userRequirements.requiredContexts) {\n        if (!this.sharedContexts.has(contextName)) {\n          console.log(`❌ Required shared context \"${contextName}\" not available yet`);\n          return false;\n        }\n      }\n      console.log(`✅ All required shared contexts available`);\n      return true;\n    }\n    \n    // Handle provider mode - always ready to create contexts\n    if (userRequirements.mode === \"provider\") {\n      console.log(`✅ Provider mode - ready to create contexts`);\n      return true;\n    }\n    \n    // Default to ready for unknown modes\n    console.log(`✅ Unknown mode - defaulting to ready`);\n    return true;\n  }\n\n  async apply(callContext: FynAppMiddlewareCallContext): Promise<void> {\n    try {\n      // Store ready callback for signaling when shared contexts are created\n      if (callContext.meta.requireReady && !this.readyCallback) {\n        this.readyCallback = callContext.meta.requireReady;\n      }\n\n      // Handle different configuration types\n      if (!callContext.meta.config) {\n        console.log(`${this.name} middleware: No configuration found for ${callContext.fynApp.name}, skipping application`);\n        return;\n      }\n\n      // Check if this is a secondary \"consume-only\" app\n      if (typeof callContext.meta.config === 'string' && callContext.meta.config === 'consume-only') {\n        console.log(`${this.name} middleware: ${callContext.fynApp.name} is a secondary consumer, exposing shared contexts only`);\n        await this.handleSecondaryConsumer(callContext);\n        return;\n      }\n\n      // Handle primary app with full configuration\n      if (typeof callContext.meta.config === 'object' && callContext.meta.config.contexts) {\n        console.log(`${this.name} middleware: ${callContext.fynApp.name} is a primary provider, processing full configuration`);\n        return;\n      }\n\n      // Handle empty/invalid configuration\n      console.log(`${this.name} middleware: Invalid configuration for ${callContext.fynApp.name}, skipping application`);\n      return;\n\n    } catch (error) {\n      console.error(`Error applying ${this.name} middleware to ${callContext.fynApp.name}:`, error);\n      throw error;\n    }\n  }\n\n  private async handlePrimaryProvider(context: FynAppMiddlewareCallContext): Promise<void> {\n    const validatedConfig = this.validateConfig(context.meta.config);\n    const contextsToProcess = this.normalizeContextsConfig(validatedConfig.contexts);\n    \n    console.log(`Processing ${contextsToProcess.length} contexts for primary provider ${context.fynApp.name}`);\n\n    // Initialize contexts for this FynApp\n    if (!this.contextInstances.has(context.fynApp)) {\n      this.contextInstances.set(context.fynApp, new Map());\n    }\n    const fynAppContexts = this.contextInstances.get(context.fynApp)!;\n\n    // Process each context configuration\n    for (const contextConfig of contextsToProcess) {\n      await this.createContext(context, contextConfig, fynAppContexts);\n    }\n\n    // Expose context APIs to the FynApp\n      this.exposeContextAPIs(context.fynApp, fynAppContexts);\n  }\n\n  private async handleSecondaryConsumer(context: FynAppMiddlewareCallContext): Promise<void> {\n    // Track this FynApp as a secondary consumer\n    this.secondaryConsumers.add(context.fynApp);\n    \n    // Initialize contexts for this FynApp\n    if (!this.contextInstances.has(context.fynApp)) {\n      this.contextInstances.set(context.fynApp, new Map());\n    }\n    const fynAppContexts = this.contextInstances.get(context.fynApp)!;\n\n    // For secondary consumers, expose access to all existing shared contexts\n    for (const [contextName, sharedFactory] of this.sharedContexts.entries()) {\n      // Create a lightweight context reference that points to the shared context\n      const sharedSymbol = this.sharedProviderSymbols.get(contextName);\n      const sharedProvider = this.sharedProviderInstances.get(contextName);\n      \n      if (sharedSymbol && sharedProvider) {\n        // Create a minimal context config for the shared context\n        const sharedConfig: ContextConfig = {\n          contextName,\n          initialState: {},\n          shared: true,\n        };\n\n        fynAppContexts.set(contextName, {\n          factory: sharedFactory,\n          config: sharedConfig,\n          shared: true,\n        });\n\n        console.log(`Secondary consumer ${context.fynApp.name} can access shared context \"${contextName}\"`);\n      }\n    }\n\n    // Always expose context APIs (even if no shared contexts exist yet)\n    this.exposeContextAPIs(context.fynApp, fynAppContexts);\n    \n    // If no shared contexts available yet, log info message\n    if (this.sharedContexts.size === 0) {\n      console.log(`Secondary consumer ${context.fynApp.name} loaded before primary provider - shared contexts will be available once primary loads`);\n    }\n  }\n\n  private validateConfig(config: any): ReactContextMiddlewareConfig {\n    if (!config || typeof config !== 'object') {\n      throw new Error('Invalid configuration: config must be an object');\n    }\n    \n    if (!config.contexts) {\n      throw new Error('Invalid configuration: contexts property is required');\n    }\n    \n    return config as ReactContextMiddlewareConfig;\n  }\n\n  private normalizeContextsConfig(contexts: ReactContextMiddlewareConfig['contexts']): ContextConfig[] {\n    if (Array.isArray(contexts)) {\n      // Legacy array format - validate each context has contextName\n      return contexts.map(ctx => {\n        if (!ctx.contextName) {\n          throw new Error('Context configuration missing contextName');\n        }\n        return ctx;\n      });\n    } else if (typeof contexts === 'object') {\n      // New object format: convert to array with contextName property\n      return Object.entries(contexts).map(([name, contextConfig]) => ({\n        ...contextConfig,\n        contextName: name\n      }));\n    } else {\n      throw new Error('Invalid contexts configuration: must be array or object');\n    }\n  }\n\n  private async createContext(context: FynAppMiddlewareCallContext, config: ContextConfig, fynAppContexts: Map<string, ContextInstanceData>): Promise<void> {\n    const contextKey = config.shared ? config.contextName : `${context.fynApp.name}-${config.contextName}`;\n\n    // For shared contexts, use the shared factory; for non-shared, create FynApp-specific factory\n    let factory: ContextFactory;\n    \n    if (config.shared) {\n      // Check if shared factory already exists\n      if (!this.sharedContexts.has(config.contextName)) {\n        console.log(`Creating shared context factory for \"${config.contextName}\"`);\n        factory = createContextProvider(config, this.storageManager);\n        this.sharedContexts.set(config.contextName, factory);\n        \n        // Create a Symbol for this shared provider\n        const sharedSymbol = Symbol(`shared-provider-${config.contextName}`);\n        this.sharedProviderSymbols.set(config.contextName, sharedSymbol);\n        \n        // Create shared state store outside React context\n        const sharedStore = this.createSharedStateStore(config);\n        this.sharedStateStores.set(config.contextName, sharedStore);\n        \n        // Create a shared Provider component that uses the shared store\n        const SharedProvider = ({ children }: { children: ReactNode }) => {\n          return React.createElement(factory.Provider, { \n            children,\n            externalState: sharedStore // Pass shared store to provider\n          });\n        };\n        this.sharedProviderInstances.set(config.contextName, SharedProvider);\n        console.log(`Created shared Provider instance with shared store for \"${config.contextName}\"`);\n        \n        // Signal that middleware is now ready (has shared contexts)\n        if (this.readyCallback && this.sharedContexts.size === 1) {\n          console.log(`🔔 ${this.name} middleware signaling ready - first shared context created`);\n          this.readyCallback();\n        }\n        \n        // Update all secondary consumers to give them access to this new shared context\n        this.updateSecondaryConsumers(config.contextName, factory);\n      } else {\n        console.log(`Reusing existing shared context factory for \"${config.contextName}\"`);\n        factory = this.sharedContexts.get(config.contextName)!;\n      }\n    } else {\n      // Create FynApp-specific factory if not exists\n      if (!this.contextFactories.has(contextKey)) {\n        console.log(`Creating FynApp-specific context factory for \"${contextKey}\"`);\n        factory = createContextProvider(config, this.storageManager);\n        this.contextFactories.set(contextKey, factory);\n      } else {\n        factory = this.contextFactories.get(contextKey)!;\n      }\n    }\n\n    // Store context instance for this FynApp\n    fynAppContexts.set(config.contextName, {\n      factory,\n      config,\n      shared: config.shared || false,\n    });\n\n    console.log(`Configured context \"${config.contextName}\" for ${context.fynApp.name} (shared: ${config.shared || false})`);\n  }\n\n  private updateSecondaryConsumers(contextName: string, factory: ContextFactory): void {\n    // Update all secondary consumers to give them access to the new shared context\n    for (const secondaryFynApp of this.secondaryConsumers) {\n      const fynAppContexts = this.contextInstances.get(secondaryFynApp);\n      if (fynAppContexts) {\n        const sharedSymbol = this.sharedProviderSymbols.get(contextName);\n        const sharedProvider = this.sharedProviderInstances.get(contextName);\n        \n        if (sharedSymbol && sharedProvider) {\n          // Create a minimal context config for the shared context\n          const sharedConfig: ContextConfig = {\n            contextName,\n            initialState: {},\n            shared: true,\n          };\n\n          fynAppContexts.set(contextName, {\n            factory,\n            config: sharedConfig,\n            shared: true,\n          });\n\n          // Re-expose context APIs to update the secondary consumer\n          this.exposeContextAPIs(secondaryFynApp, fynAppContexts);\n          \n          console.log(`Updated secondary consumer ${secondaryFynApp.name} with new shared context \"${contextName}\"`);\n        }\n      }\n    }\n  }\n\n  private createSharedStateStore(config: ContextConfig): any {\n    // Create a shared state store based on the context configuration\n    if (config.contextName === 'counter') {\n      // For counter context, create a shared store with counter state\n      const listeners = new Set<() => void>();\n      let state = { count: 0 };\n      \n      const sharedStore = {\n        getState: () => state,\n        setState: (newState: any) => {\n          state = { ...state, ...newState };\n          // Notify all listeners\n          listeners.forEach(listener => listener());\n        },\n        subscribe: (listener: () => void) => {\n          listeners.add(listener);\n          return () => listeners.delete(listener);\n        },\n        // Counter-specific methods\n        increment: () => {\n          state = { ...state, count: state.count + 1 };\n          listeners.forEach(listener => listener());\n        },\n        decrement: () => {\n          state = { ...state, count: state.count - 1 };\n          listeners.forEach(listener => listener());\n        },\n        reset: () => {\n          state = { ...state, count: 0 };\n          listeners.forEach(listener => listener());\n        }\n      };\n      \n      console.log(`Created shared state store for counter context`);\n      return sharedStore;\n    }\n    \n    // Default shared store for other contexts\n    return {\n      getState: () => ({}),\n      setState: () => {},\n      subscribe: () => () => {}\n    };\n  }\n\n  private exposeContextAPIs(fynApp: FynApp, fynAppContexts: Map<string, ContextInstanceData>): void {\n    // Expose context hooks and utilities to the FynApp\n    const contextAPIs: Record<string, any> = {};\n    const sharedProviderSymbols: Record<string, symbol> = {}; // NEW: Collect symbols for shared providers\n    \n    for (const [contextName, contextData] of fynAppContexts.entries()) {\n      const { factory, config } = contextData;\n      \n      if (config.shared) {\n        // For shared contexts, provide the shared Provider instance and symbol\n        const sharedProvider = this.sharedProviderInstances.get(contextName);\n        const sharedSymbol = this.sharedProviderSymbols.get(contextName);\n        \n        contextAPIs[contextName] = {\n          useContext: factory.useContext,\n          useContextSelector: factory.useContextSelector,\n          Context: factory.Context,\n          Provider: factory.Provider, // Original Provider (for manual use)\n          SharedProvider: sharedProvider, // Pre-configured shared Provider\n        };\n        \n        if (sharedSymbol) {\n          sharedProviderSymbols[contextName] = sharedSymbol;\n        }\n        \n        console.log(`Exposed shared Provider for context \"${contextName}\" to ${fynApp.name}`);\n      } else {\n        // For non-shared contexts, provide the regular Provider\n        contextAPIs[contextName] = {\n          useContext: factory.useContext,\n          useContextSelector: factory.useContextSelector,\n          Context: factory.Context,\n          Provider: factory.Provider,\n        };\n      }\n    }\n\n    // Method to get shared provider by symbol\n    const getSharedProvider = (symbol: symbol): React.ComponentType<{ children: ReactNode }> | undefined => {\n      for (const [contextName, contextSymbol] of this.sharedProviderSymbols.entries()) {\n        if (contextSymbol === symbol) {\n          return this.sharedProviderInstances.get(contextName);\n        }\n      }\n      return undefined;\n    };\n\n    // Lazy getter for shared symbols - allows access even if contexts aren't created yet\n    const getLazySharedSymbols = (): Record<string, symbol> => {\n      const symbols: Record<string, symbol> = {};\n      for (const [contextName, symbol] of this.sharedProviderSymbols.entries()) {\n        symbols[contextName] = symbol;\n      }\n      return symbols;\n    };\n\n    // Store APIs in middlewareContext (kernel guarantees this exists)\n    fynApp.middlewareContext.set(this.name, { \n      ...contextAPIs, \n      getSharedProvider, // Add the method to get shared providers by symbol\n      getLazySharedSymbols // Add lazy getter for shared symbols\n    });\n    \n    // Store shared provider symbols under a documented key (with lazy getter)\n    fynApp.middlewareContext.set(`${this.name}:shared-symbols`, getLazySharedSymbols());\n    \n    if (Object.keys(sharedProviderSymbols).length > 0) {\n      console.log(`Stored shared provider symbols for ${Object.keys(sharedProviderSymbols).join(', ')} in ${fynApp.name}`);\n    }\n    \n    console.log(`Exposed ${Object.keys(contextAPIs).join(', ')} context APIs to ${fynApp.name} via middlewareContext`);\n  }\n\n  // Cleanup method for proper disposal\n  public cleanup(fynApp: FynApp): void {\n    const contexts = this.contextInstances.get(fynApp);\n    if (contexts) {\n      for (const [contextName, contextData] of contexts.entries()) {\n        if (contextData.config.persistence) {\n          // Clear persistence if needed\n          this.storageManager.clear(contextData.config.persistence, \n            contextData.shared ? undefined : fynApp.name);\n        }\n      }\n      this.contextInstances.delete(fynApp);\n    }\n    \n    // Remove from secondary consumers tracking\n    this.secondaryConsumers.delete(fynApp);\n  }\n\n  // Debug method to list active contexts\n  public listContexts(fynApp?: FynApp): string[] {\n    if (fynApp) {\n      const contexts = this.contextInstances.get(fynApp);\n      return contexts ? Array.from(contexts.keys()) : [];\n    }\n    return Array.from(this.contextFactories.keys());\n  }\n}\n"],"names":["StorageManager","constructor","this","memoryStorage","Map","getStorageKey","config","fynAppId","key","getStorageType","storage","type","load","initialState","storageType","stored","window","localStorage","getItem","sessionStorage","get","parsedState","JSON","parse","error","console","warn","save","state","serialized","stringify","setItem","set","clear","removeItem","delete","createContextProvider","storageManager","Context","createContext","undefined","useContextHook","context","useContext","Error","contextName","Provider","children","externalState","internalState","setInternalState","useState","getState","persistence","setState","useMemo","prevStateRef","useRef","useEffect","subscribe","newState","current","actions","actionMap","Object","entries","forEach","actionName","actionDef","args","prevState","actionFn","validator","reducer","middleware","_a","validation","result","_b","onStateChange","_c","onError","String","setStateGeneric","useCallback","updater","currentState","value","React","createElement","useContextSelector","selector","exports","name","contextFactories","contextInstances","WeakMap","sharedContexts","sharedProviderInstances","sharedProviderSymbols","sharedStateStores","secondaryConsumers","Set","setup","_context","log","isReadyForUser","userRequirements","mode","requiredContexts","has","apply","callContext","meta","requireReady","readyCallback","fynApp","handleSecondaryConsumer","contexts","handlePrimaryProvider","validatedConfig","validateConfig","contextsToProcess","normalizeContextsConfig","length","fynAppContexts","contextConfig","exposeContextAPIs","add","sharedFactory","sharedSymbol","sharedProvider","sharedConfig","shared","factory","size","Array","isArray","map","ctx","contextKey","Symbol","sharedStore","createSharedStateStore","SharedProvider","updateSecondaryConsumers","secondaryFynApp","listeners","count","listener","increment","decrement","reset","contextAPIs","contextData","getLazySharedSymbols","symbols","symbol","middlewareContext","getSharedProvider","contextSymbol","keys","join","cleanup","listContexts","from"],"mappings":"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"}